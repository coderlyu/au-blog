# 单例模式 (Singleton)

## 简介

1. **单例模式（Singleton）**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。
2. **单例 （Singleton）** 类声明了一个名为 `get­Instance` 获取实例的静态方法来返回其所属类的一个相同实例。
   - 单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 `get­Instance` 方法必须是获取单例对象的唯一方式。

## 案例

1. 线程池
2. 全局缓存
3. 浏览器中的 window 对象
4. 网页登录浮窗

### 例子

```js
function Singleton(name) {
  this.name = name;
}
Singleton.prototype.getName = function() {
  return this.name;
};
Singleton.getInstance = (function() {
  let instance = null;
  return function(name) {
    if (!instance) {
      instance = new Singleton(name);
    }
    return instance;
  };
})();

const instance1 = Singleton.getInstance("111");
const instance2 = Singleton.getInstance("222");
console.log(instance1 === instance2); // 输出true
```

## 优缺点

**优点：**

1. **控制实例数量**：单例模式可以确保系统中一个类只有一个实例，避免了实例的重复创建，节约系统资源。
2. **全局访问点**：单例模式提供了一个全局访问点，可以方便地访问实例，适合需要频繁使用的对象，比如配置对象、日志对象等。
3. **延迟加载**：可以实现延迟加载，即实例在第一次使用时才会被创建，从而减少系统启动时间和资源消耗。
4. **线程安全**：通过适当的实现方法（如双重检查锁定或静态内部类），单例模式可以实现线程安全，确保在多线程环境下实例的唯一性。

**缺点：**

1. **难以扩展**：由于单例模式限制了实例的数量和创建方式，使得它在扩展时较为困难。例如，如果需要从单例模式转为多例模式，代码的改动会比较大。
2. **隐藏依赖关系**：单例模式会隐藏类与类之间的依赖关系，使得代码难以测试和维护。单例模式的依赖通常不是通过构造函数注入，而是通过静态方法获取，增加了代码的耦合度。
3. **不利于并行开发**：单例模式的全局性可能导致不同模块间的耦合和依赖，影响并行开发。多个开发人员同时修改单例类时，可能会引发冲突。
4. **可能导致资源滥用**：如果单例类持有的资源过多或生命周期过长，可能会导致资源的滥用和内存泄漏问题。
5. **违反单一职责原则**：单例模式有时会承担过多的职责，因为它往往作为全局访问点，容易被滥用，承担过多的功能，从而违反单一职责原则。

**总结：**
单例模式在控制全局状态、减少资源浪费和提供全局访问点方面具有显著优势，但在扩展性、测试性和模块化方面存在缺陷。使用单例模式时，需要根据具体场景权衡其优缺点，并采取适当的措施（如使用依赖注入、避免过度使用）来减轻其不足之处。
