# 网络安全

> [参考](https://juejin.cn/post/7095945284504518663)

## 介绍下 https 中间人攻击

HTTPS 中间人攻击（MITM，Man-in-the-Middle Attack）是一种网络攻击方式，攻击者通过拦截、篡改或伪造通信双方之间的数据传输，来窃取敏感信息或冒充一方与另一方进行通信。即使 HTTPS 通信使用了加密，攻击者仍然可能利用中间人攻击获取机密数据。以下是 HTTPS 中间人攻击的常见形式：

1. 证书伪造

攻击者通过伪造或替换服务器的 SSL/TLS 证书，来冒充合法网站。当用户访问 HTTPS 网站时，浏览器会验证网站的 SSL 证书，如果攻击者能让受害者信任一个假的证书，用户的流量就可能被重定向到攻击者的服务器。这种方式常见于不安全的公共 Wi-Fi 网络或 DNS 劫持。

2. SSL 剥离攻击（SSL Strip Attack）

在 SSL 剥离攻击中，攻击者会将 HTTPS 请求降级为 HTTP 请求。原理是在用户和服务器之间插入代理，攻击者向用户发送 HTTP 明文数据，而向服务器发送 HTTPS 加密数据。这样，用户与攻击者之间的通信是未加密的，攻击者可以读取所有传输的数据。

3. 中间人代理

攻击者设置一个代理服务器，充当用户和目标服务器之间的中介。通过这种方式，攻击者可以解密用户发出的 HTTPS 请求，读取和篡改其中的信息。某些情况下，如果攻击者能控制用户的网络（如公共 Wi-Fi 或本地网络），他们可以重定向流量通过代理服务器。

4. 不信任的 CA（证书颁发机构）

如果某些证书颁发机构（CA）不可信或者被攻破，攻击者可以获得伪造的 SSL 证书，并使用这些证书进行中间人攻击。现代浏览器通过内置信任的根证书列表，来避免这种情况，但依然可能有小部分不安全的 CA 未被及时移除。

如何防范 HTTPS 中间人攻击：

    •	验证证书的有效性：使用浏览器检查网站的 SSL 证书是否由信任的 CA 颁发，是否与网站匹配，证书是否过期。
    •	HSTS（HTTP Strict Transport Security）：HSTS 可以强制客户端始终通过 HTTPS 与服务器通信，防止 SSL 剥离攻击。
    •	启用双向 SSL 验证：不仅客户端验证服务器的证书，服务器也验证客户端的证书。
    •	使用 VPN：在不安全的网络环境中，VPN 可以加密整个网络流量，防止流量被中间人攻击。

## 简述 TCP 连接的过程

TCP（传输控制协议）连接的过程通常分为三个阶段：连接建立、数据传输和连接终止。其中，连接的建立和终止尤为重要，具体步骤如下：

1. 连接建立（三次握手）

TCP 连接的建立采用了“三次握手”机制，确保通信双方都能准备好发送和接收数据。具体过程如下：

    •	第一次握手（客户端 -> 服务端）：客户端发送一个 SYN（同步序列号）包，表明希望建立连接，同时包含一个初始的序列号 seq=x。
    •	第二次握手（服务端 -> 客户端）：服务器收到 SYN 包后，回复一个 SYN-ACK 包。该包表示服务器同意连接，并包含服务器的序列号 seq=y 和对客户端序列号的确认 ack=x+1，即客户端的序列号加 1。
    •	第三次握手（客户端 -> 服务端）：客户端收到服务器的 SYN-ACK 包后，发送一个 ACK 包确认服务器的序列号 ack=y+1，表示连接已建立。

通过三次握手，客户端和服务器双方确认了对方的接收能力以及初始序列号，保证了连接的可靠性。

2. 数据传输

一旦连接建立，客户端和服务器之间可以进行双向数据传输。数据通过 TCP 包按顺序发送，并通过序列号和确认号确保数据的正确传递。TCP 还提供流量控制和拥塞控制机制，确保网络的稳定性和传输效率。

    •	序列号（Sequence Number）：用于标识数据包的顺序，确保接收端能按顺序重组数据。
    •	确认号（Acknowledgment Number）：用于确认已经接收的数据包，发送端根据确认号决定是否重传丢失的数据包。

3. 连接终止（四次挥手）

TCP 连接的关闭使用“四次挥手”机制，以确保双方都能安全断开连接。具体步骤如下：

    •	第一次挥手（客户端 -> 服务端）：客户端发送一个 FIN（结束标志）包，表示客户端的数据已经发送完毕，想关闭连接。
    •	第二次挥手（服务端 -> 客户端）：服务器收到 FIN 包后，发送一个 ACK 包，确认已经收到关闭请求。但此时服务器可能还有数据要发送，因此连接处于“半关闭”状态。
    •	第三次挥手（服务端 -> 客户端）：当服务器也完成数据发送后，发送一个 FIN 包，表示准备关闭连接。
    •	第四次挥手（客户端 -> 服务端）：客户端收到服务器的 FIN 包后，发送一个 ACK 包确认，然后关闭连接。

在四次挥手的过程中，双方都可以确保数据传输完全结束，避免数据丢失。

总结

    •	三次握手用于建立可靠的连接，确保双方准备就绪。
    •	四次挥手用于安全关闭连接，确保双方没有未传输的数据。
    •	数据传输期间，TCP 通过序列号、确认号以及流量控制等机制确保数据的有序、完整传递。

## 介绍下 http1.0、http1.1、http2.0 协议的区别？

HTTP（超文本传输协议）经历了多个版本的更新，每个版本的改进都旨在提升性能和效率。下面介绍 HTTP/1.0、HTTP/1.1 和 HTTP/2.0 之间的主要区别：

1. HTTP/1.0

发布年份：1996 年

HTTP/1.0 是最早的 HTTP 版本，具有以下特点：

    •	每个请求建立一个新连接：在 HTTP/1.0 中，每发起一个 HTTP 请求都会创建一个新的 TCP 连接，服务器响应完毕后就关闭连接。这种方式的效率很低，特别是在加载网页中多个资源（如图片、CSS、JS 文件）时，频繁的建立和关闭连接导致较高的网络开销和延迟。
    •	无持久连接：HTTP/1.0 默认不支持持久连接，即一次请求只能传递一个文件，不能复用连接。
    •	请求方法有限：HTTP/1.0 主要支持 GET、POST 和 HEAD 方法，没有明确的规范来支持其他常见方法（如 PUT、DELETE）。

2. HTTP/1.1

发布年份：1997 年

HTTP/1.1 是对 HTTP/1.0 的重大改进，目前仍然是最广泛使用的 HTTP 版本。它的特点包括：

    •	持久连接（Keep-Alive）：HTTP/1.1 默认启用了持久连接，允许多个请求和响应在一个 TCP 连接中传输。连接在请求完成后不会立即关闭，可以重用以减少建立和关闭连接的开销，提升性能。
    •	管道化（Pipelining）：HTTP/1.1 支持请求管道化，即客户端可以在收到响应前就发送多个请求，服务器按顺序处理这些请求。这种方式可以减少等待时间，但由于中间代理和服务器的支持不佳，管道化功能很少在实际中被广泛应用。
    •	缓存控制：HTTP/1.1 引入了更丰富的缓存机制，通过 Cache-Control、ETag、If-Modified-Since 等字段，客户端和服务器可以更灵活地控制资源的缓存，提升页面加载效率。
    •	分块传输编码（Chunked Transfer Encoding）：当服务器无法一次性生成完整的响应时，HTTP/1.1 支持分块传输编码，允许服务器分块传输响应内容，使客户端可以逐步接收数据。
    •	更多的请求方法：HTTP/1.1 明确引入了 PUT、DELETE、OPTIONS、TRACE 等方法，扩展了协议的功能。

3. HTTP/2.0

发布年份：2015 年

HTTP/2.0 是对 HTTP 协议的一个重大升级，旨在解决 HTTP/1.x 中的性能问题，特别是在现代网络环境下加载大量资源时的效率。主要特点包括：

    •	二进制帧：HTTP/2.0 使用二进制帧传输，而不是 HTTP/1.x 的纯文本协议。二进制协议更加高效、紧凑，且易于解析。
    •	多路复用（Multiplexing）：HTTP/2.0 允许在一个 TCP 连接中并发处理多个请求和响应，不再像 HTTP/1.x 那样只能按顺序处理。这样可以大幅减少阻塞问题（如 “队头阻塞”），提升传输效率。
    •	头部压缩：HTTP/2.0 使用 HPACK 算法对 HTTP 头部进行压缩，减少了头部信息的传输开销。特别是在移动网络和慢速网络上，这能显著提升传输性能。
    •	服务器推送（Server Push）：HTTP/2.0 允许服务器主动向客户端推送资源，而不是等待客户端请求。例如，当客户端请求 HTML 页面时，服务器可以提前推送该页面依赖的 CSS、JS 等文件，减少客户端的请求次数，提升页面加载速度。
    •	优先级控制：HTTP/2.0 支持请求优先级控制，允许客户端指定某些请求的优先级，服务器可以根据优先级决定响应顺序，优化资源加载顺序。

总结对比：

版本 HTTP/1.0 HTTP/1.1 HTTP/2.0
连接 每个请求一个连接 支持持久连接，多个请求复用一个连接 多路复用，一个连接并发多个请求
管道化 不支持 支持，但实际应用较少 不需要，使用多路复用取代
缓存 基础的缓存机制 丰富的缓存控制，如 Cache-Control、ETag 与 HTTP/1.1 类似，但头部压缩提高效率
头部 无压缩，每次请求都发送完整头部 无压缩，每次请求都发送完整头部 头部压缩，减少冗余
优先级 不支持 不支持 支持请求优先级
传输 纯文本 纯文本 二进制帧传输，性能更高
服务器推送 不支持 不支持 支持服务器主动推送资源

总体来说，HTTP/2.0 在性能和效率上对比 HTTP/1.x 有显著提升，尤其是在现代 Web 环境中，大量资源的并行加载和减少延迟方面表现更好。

## 前端常见的攻击手段

在前端开发中，常见的网络攻击手段及其防御措施如下：

---

### 1. **跨站脚本攻击 (XSS, Cross-Site Scripting)**

#### 描述：

攻击者通过向网页中注入恶意 JavaScript 代码，从而在用户浏览器中执行任意代码。

#### 常见形式：

- **存储型 XSS**：恶意代码被存储在服务器数据库中，并在请求页面时加载执行。
- **反射型 XSS**：恶意代码通过 URL 参数或表单提交嵌入，返回给用户并执行。
- **DOM 型 XSS**：攻击者利用前端 JavaScript 操作 DOM 的漏洞注入代码。

#### 防御措施：

- **输出编码**：对 HTML、URL、JS 等输出进行编码（如使用 `escapeHtml`）。
- **输入验证**：限制输入的类型和长度。
- **CSP (Content Security Policy)**：限制页面中可执行的 JavaScript 源。
- **HttpOnly Cookie**：避免客户端 JavaScript 访问敏感 Cookies。

---

### 2. **跨站请求伪造 (CSRF, Cross-Site Request Forgery)**

#### 描述：

攻击者诱导用户在已登录的情况下访问恶意链接，从而执行非预期的操作（如转账或账户操作）。

#### 防御措施：

- **CSRF Token**：在表单或请求中加入唯一的防伪标识。
- **SameSite Cookie**：将 Cookie 设置为 `SameSite=Lax/Strict`，减少跨站请求的影响。
- **双重提交 Cookie**：请求中携带同一个 Token，同时检查是否与 Cookie 匹配。

---

### 3. **点击劫持 (Clickjacking)**

#### 描述：

攻击者将目标页面嵌入隐藏的 iframe 中，诱使用户在不知情的情况下点击特定按钮或链接。

#### 防御措施：

- **X-Frame-Options**：通过响应头禁用页面在 iframe 中加载 (`DENY` 或 `SAMEORIGIN`)。
- **Content-Security-Policy (CSP)**：限制页面资源加载的源，防止 iframe 嵌套。
- **视觉混淆检测**：判断页面是否处于 iframe 内或通过用户交互验证。

---

### 4. **JSON 劫持 (JSON Hijacking)**

#### 描述：

攻击者通过加载 JSON 数据，窃取用户隐私信息，尤其是在没有防护的 JSONP 请求中。

#### 防御措施：

- **修改返回数据格式**：将 JSON 包裹在不可直接解析的对象中，如：`while(1);{...}`。
- **使用 POST 请求**：避免敏感数据通过 GET 暴露在 URL 中。
- **设置 CORS**：确保只允许受信任的域请求 JSON 数据。

---

### 5. **HTTP 缓存投毒 (HTTP Cache Poisoning)**

#### 描述：

攻击者利用缓存服务器的缓存机制，将恶意响应存储在缓存中，返回给其他用户。

#### 防御措施：

- **严格校验输入**：防止恶意数据进入服务器响应。
- **缓存控制**：设置合理的缓存策略，避免敏感内容被缓存。
- **Vary Header**：根据不同的请求头（如 `User-Agent`）区分缓存内容。

---

### 6. **代码注入攻击**

#### 描述：

攻击者将恶意代码注入页面，劫持页面功能或破坏数据。

#### 防御措施：

- 使用模板引擎时避免将未转义的变量直接嵌入 HTML。
- 使用沙箱模式或 CSP 限制第三方脚本的权限。

---

### 7. **WebSocket 劫持**

#### 描述：

攻击者利用未验证的 WebSocket 连接进行恶意操作。

#### 防御措施：

- 在 WebSocket 握手时进行身份验证（如 Token）。
- 使用 WSS（WebSocket Secure）协议加密通信。
- 检查 Origin 头，防止跨域连接。

---

### 8. **敏感数据泄露**

#### 描述：

敏感数据（如密码、Token）在传输或存储过程中被窃取。

#### 防御措施：

- 使用 HTTPS 加密通信。
- 在浏览器端避免存储敏感信息，如 Token 放入 `localStorage`。
- **Content-Security-Policy** 配置，防止外部资源泄露敏感数据。

---

### 总结

前端开发中网络攻击手段多种多样，开发者需要从多个层面（如输入验证、响应编码、身份验证和加密传输）入手进行防御。配合安全响应头（如 CSP 和 X-Frame-Options）以及使用 HTTPS 能显著减少攻击面。

是否需要更深入探讨某一种攻击类型？
