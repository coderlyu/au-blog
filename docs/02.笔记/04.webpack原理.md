---
title: Webpack原理
date: 2021-05-01 08:56:57
meta:
  - name: keywords
  - content: Webpack原理,Webpack
permalink: /pages/6aa311/
categories:
  - Webpack
tags:
  - Webpack
---

# Webpack原理

## bundle.js 文件分析

### 文件准备

- src/index.js

```js
const vars = require('./variable')
const calcs = require('./calc')

console.log('结果：' + calcs.add(1, 2, 3, 4, 5))
console.log('i am ' + vars.name)
```

- src/variable.js

```js
const name = 'coderly'

module.exports = {
  name
}
```

- src/calc.js

```js
module.exports = {
  add(...nums) {
    return nums.reduce((p, c) => p + c, 0)
  }
}
```

打包之后的文件(删除无关注释)
```js{35-39,43-44}
(() => {
  var __webpack_modules__ = ({
    "./src/calc.js":
      ((module) => {
        // 做了优化，未使用 __webpack_require__ 将不再作为变量传入
        // 在 module.exports 上添加变量，最终是在 __webpack_module_cache__ 对象中的模块中添加了代码
        eval("module.exports = {\r\n  add(...nums) {\r\n    return nums.reduce((p, c) => p + c, 0)\r\n  }\r\n}\n\n//# sourceURL=webpack://webpack-test/./src/calc.js?");
      }),
    "./src/index.js":
      ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
        // 递归加载 variable.js 和 calc.js
        eval("const vars = __webpack_require__(/*! ./variable */ \"./src/variable.js\")\r\nconst calcs = __webpack_require__(/*! ./calc */ \"./src/calc.js\")\r\n\r\nconsole.log('结果：' + calcs.add(1, 2, 3, 4, 5))\r\nconsole.log('i am ' + vars.name)\n\n//# sourceURL=webpack://webpack-test/./src/index.js?");
      }),
    "./src/variable.js":
      ((module) => {
        eval("const name = 'coderly'\r\n\r\nmodule.exports = {\r\n  name\r\n}\n\n//# sourceURL=webpack://webpack-test/./src/variable.js?");
      })
  });
  // 缓存 - 用来判断文件是否已加载
  var __webpack_module_cache__ = {};

  function __webpack_require__ (moduleId) {

    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    // 构建 模块并添加进缓存
    var module = __webpack_module_cache__[moduleId] = {
      // no module.id needed
      // no module.loaded needed
      exports: {}
    };

    // 执行 模块对应的代码
    // module 变量传入的是一个引用，做的修改将会直接作用在 __webpack_module_cache__ 对应模块中
    // __webpack_require__ 递归加载文件
    // require 无法在 浏览器环境下使用，所以命名 __webpack_require__
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);

    return module.exports;
  }
  // 开始加载 入口文件
  var __webpack_exports__ = __webpack_require__("./src/index.js");
})();
```
**说明**
- `__webpack_require__` 其实就是 `require`（因为require 无法在*浏览器环境*下使用，所以命名 __webpack_require__）
- 从入口文件开始加载文件执行
- 遇到需要 `require` 的，会先递归执行 `__webpack_require__`函数，并 `return module.exports`
- 以上例分析
  1. 先执行 "./src/index.js" 对应值的代码
  2. 第一行遇到 const vars = __webpack_require__(/*! ./variable */ \"./src/variable.js\")，开始执行 "./src/variable.js\" 对应值的代码
  3. "./src/variable.js\" 对应的代码中 在执行完 `__webpack_require__` 函数后，return 了 module.exports，"./src/index.js" 对应代码中获取到了 "./src/variable.js\" 导出的函数
  4. 第二行遇到 const calcs = __webpack_require__(/*! ./calc */ \"./src/calc.js\")
  5. TODO

## loader

执行顺序： **从下至上，从右至左**

### this 上的属性说明

|       属性            |        作用       |        参数             |                 返回值         |
| --------------------- | ----------------- | ----------------------- | -----------------------------  |
| addContextDependency  | 添加一个目录作为加载程序结果的依赖项 | directory：string | ——                 |
| addDependency  | 添加文件作为加载程序结果的依赖项，以使其可观察 | file：string    | ——                |
| async  | 告诉加载程序运行程序加载程序打算异步回调。返回this.callback | ——    | this.callback          |
| cacheable  | 设置可缓存标志的函数 | flag：boolean   | ——                 |
| callback  | 可以同步或异步调用以返回多个结果的函数 | （err: Error/null, content: string|Buffer, sourceMap?: SourceMap, meta?: any）   | ——                 |
| clearDependencies  | 删除加载程序结果的所有依赖关系，甚至包括初始依赖关系和其他加载程序的依赖关系 | ——           | ——                 |
| context  | 模块所在的目录。可以用作解析其他模块路径的上下文 | ——           | ——                 |
| data  |  在 pitch 阶段和正常阶段之间共享的 data 对象 | ——           | ——                 |
| emitError  |  发出一个错误，该错误也可以显示在输出中 | error: Error           | ——                 |
| emitFile  |  产生一个文件。这是 webpack 特有的 | (name: string, content: Buffer/string, sourceMap: {...})          | ——                 |
| emitWarning  |  发出警告，该警告将在输出中显示 | warning: Error          | ——                 |
| fs  |  用于访问 compilation 的 inputFileSystem 属性 | ——         | ——                 |
| getOptions  |  提取给定的加载程序选项 | schema：JSON模式参数      | ——                 |
| getResolve  |  创建类似于的解析函数this.resolve | 函数重载      | ——                 |
| hot  |  loaders 热模块替换的相关信息 | ——      | ——                 |
| importModule  | 子编译器在构建时编译和执行请求的另一种轻量级解决方案 | (request, options, [callback]): Promise      | ——                 |
| loaderIndex  | 当前loader 在 loader 数组中的索引 | (request: string, callback: function(err, source, sourceMap, module))     | ——                 |
| loadModule  | 将给定的请求解析为模块，应用所有已配置的 loader，并使用生成的source，sourceMap和模块实例（通常是的实例NormalModule）进行回调 | (request: string, callback: function(err, source, sourceMap, module))     | ——                 |
| loaders  | loader 数组，可以在 pitch 阶段写入 | ——    | ——                 |
| mode  | webpack 在 哪个模式下运行 | ——    | production/development/none                 |
| query  | 如果这个 loader 配置了 options 对象的话，this.query 就指向这个 option 对象; 如果 loader 中没有 options，而是以 query 字符串作为参数调用时，this.query 就是一个以 ? 开头的字符串 | ——    | production/development/none               |
| request  | 解析的请求字符串 | ——    | production/development/none               |
| resolve  | 解析操作的所有依赖项将作为依赖项自动添加到当前模块 | (context: string, request: string, callback: function(err, result: string))    |  ——               |
| resource  | request 中的资源部分，包括 query 参数 | ——          |  ——               |
| resourcePath  | 资源文件的路径 | ——          |  ——               |
| resourceQuery  | 资源的 query 参数 | ——          |  ——               |
| rootContext  | 从webpack 4开始，以前 this.options.context 替换为 this.rootContext | ——          |  ——               |
| sourceMap  | 应该生成一个 source map。因为生成 source map 可能会非常耗时，你应该确认 source map 确实有必要请求 | ——          |  ——               |
| target  | 编译的目标。从配置选项中传递过来的 | ——          |  web/node               |
| utils  | 访问 contextify 和 absolutify 实用工具 | ——          |  ——               |
| version  | loader API 版本 | ——          |  ——               |
| webpack  | 如果是由 webpack 编译的，这个布尔值会被设置为真 | ——          |  ——               |
| *_compilation*  | 访问webpack的当前Compilation对象 | ——          |  ——               |
| *_compiler*  | 访问webpack的当前Compiler对象 | ——          |  ——               |

### 如何编写 loader

::: tip 实现 vars-usage-times-loader
- 统计某个变量在文件中使用到的次数
- 使用 loader-utils 插件来提取 query
- 确定 use loader 传参字段
:::

- webpack.config.js

```js{4-7,12-17}
module.exports = {
  mode:　'development',
  entry: './src/index.js',
  resolveLoader: {
    // 自定义模块解析
    modules: ['./loader', 'node_modules'],
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: {
          loader: 'vars-usage-times-loader',
          options: {
            varname: 'works'
          }
        }
      }
    ]
  }
}
```

- loader/vars-usage-times-loader.js

```js{8,24-25,31}
const parser = require('@babel/parser')
const generator = require('@babel/generator').default
const traverse = require('@babel/traverse').default
const loaderUtils = require('loader-utils')

module.exports = function(source) {
  // 获取在 webpack.config.js 中传入的参数
  const options = loaderUtils.getOptions(this)
  // 将文件转换成 ast
  let ast = parser.parse(source)
  // 遍历 ast
  traverse(ast, {
    // 如果是函数调用
    CallExpression(p) {
      // 获取当前函数调用的名字
      let name = p.node.callee.name
      // 只匹配 require 的变量
      if (name === 'require') {
        // 获取 require 文件起的变量名
        let varName = p.parent.id.name
        // 如果该变量名和 传入的相匹配
        if (varName && varName === options.varname) {
          // 开始获取该变量名在当前文件中使用的次数
          let currentBinding = p.scope.getBinding(p.parent.id.name)
          console.log(`${options.varname} 变量在当前文件中变量使用了：${currentBinding.references} 次`)
        }
      }
    }
  })
  // 重新将 ast 生成代码
  source = generator(ast).code
  return source
}
```
说明：
- 获取在 webpack.config.js 中传入的参数
- 将文件转换成 ast
- 遍历 ast，获取当前函数调用的名字只匹配 require 的变量
- 获取 require 文件起的变量名，如果该变量名和 传入的相匹配，开始获取该变量名在当前文件中使用的次数
- 重新将 ast 生成代码

至此一个简单的 loader 插件就完成了

## plugin

- 一个 JavaScript 命名函数
- 在插件函数的 prototype 上定义一个 apply 方法
- 指定一个绑定到 webpack 自身的事件钩子
- 处理 webpack 内部实例的特定数据
- 功能完成后调用 webpack 提供的回调

### webpack 的生命周期钩子

> [官方文档位置](https://webpack.js.org/api/compiler-hooks/)


|    钩子     |            作用                    |         参数   |     类型      |
| --------    | --------------------------------   | -------------  | ------------ |
| environment | 在初始化配置文件中的插件之后，在准备编译器环境时调用 |  ——  | SyncHook |
| afterEnvironment | environment编译器环境设置完成后，在挂钩之后立即调用 |  —— | SyncHook |
| **entryOption** | 在处理完webpack选项中的entry配置后调用 | context, entry | SyncBailHook |
| **afterPlugins** | 在设置初始内部插件集之后调用 | compiler | SyncHook |
| afterResolvers | 解析器设置完成后触发 | compiler | SyncHook |
| initialize | 在初始化编译器对象时调用 |  ——   | SyncHook |
| beforeRun | 在运行编译器之前添加一个挂钩 |  compiler  | AsyncSeriesHook |
| **run** | 开始阅读之前，请先钩住编译器records |  compiler  | AsyncSeriesHook |
| watchRun | 在触发新的编译之后但实际开始编译之前，在监视模式下执行插件 |  compiler  | AsyncSeriesHook |
| normalModuleFactory | 在创建NormalModuleFactory之后调用 |  normalModuleFactory  | SyncHook |
| contextModuleFactory | 创建ContextModuleFactory后运行插件 |  contextModuleFactory  | SyncHook |
| beforeCompile | 创建编译参数后执行插件 |  compilationParams  | AsyncSeriesHook |
| **compile** | beforeCompile在创建新编译之前，在之后立即调用 |  compilationParams  | SyncHook |
| thisCompilation | 在初始化编译时执行，恰好在发出compilation事件之前执行 |  compilation, compilationParams  | SyncHook |
| compilation | 创建编译后运行插件 |  compilation, compilationParams  | SyncHook |
| **make** | 在完成编译之前执行 |  compilation  | AsyncParallelHook |
| afterCompile | 在完成并密封编译后调用 |  compilation  | AsyncSeriesHook |
| shouldEmit | 在释放资产之前调用。应该返回一个布尔值，告诉是否发出 |  compilation  | SyncBailHook |
| **emit** | 在将资产释放到输出目录之前立即执行 |  compilation  | AsyncSeriesHook |
| afterEmit | 在将资产释放到输出目录后调用 |  compilation  | AsyncSeriesHook |
| assetEmitted | 当资产被放出时执行。提供对有关发出的资产的信息的访问，例如其输出路径和字节内容 |  file, info  | AsyncSeriesHook |
| **done** | 编译完成后执行 |  stats  | AsyncSeriesHook |
| additionalPass | 该挂钩使您可以再进行一次构建 |  ——  | AsyncSeriesHook |
| failed | 如果编译失败则调用 |  error  | SyncHook |
| invalid | 当监视编译无效时执行 |  fileName, changeTime  | SyncHook |
| watchClose | 监视编译停止时调用 |  ——  | SyncHook |
| infrastructureLog | 当通过infrastructureLoggingoption在配置中启用时，允许使用基础结构日志记录 |  name, type, args  | SyncBailHook |
| log | 允许登录到统计启用时，看到stats.logging，stats.loggingDebug和stats.loggingTrace选项。 |  origin, logEntry  | SyncBailHook |

#### tapable 类型说明

1. **基本的钩子**：这个钩子只会简单的调用每个 tap 进去的函数（钩子类名没有waterfall, Bail, 或者 Loop 的）
2. **Waterfall**：一个 waterfall 钩子，也会调用每个tap进去的函数；不同的是：它会将前一个函数的返回的值作为形式参数传递到下一个函数
3. **Bail**：Bail 钩子允许提前退出，当任何一个 tap 进去的函数返回任意值时，bail 钩子会停止执行其他 tap 的函数（类似 Promise.race()）
4. **Loop**：当 loop 钩子中的插件有一个返回一个未定义( non-undefined )的值时，钩子将从第一个插件重新启动。直到所有插件返回 undefined

5. **Sync**：一个同步钩子只能 tap 同步函数，不然会报错
6. **AsyncSeries**：一个 async-series 钩子，可以 tap 同步钩子, 基于回调的钩子和一个基于promise的钩子，它会按顺序的调用每个方法
7. **AsyncParallel**：一个 async-parallel 钩子跟上面的 async-series 一样，不同的是它会把异步钩子并行执行(并行执行就是把异步钩子全部一起开启，不按顺序执行)

#### webpack 回调参数说明

| 参数类型 | 说明 |
| -------- | ------ |
| context  |基本目录，一个绝对路径，用于从配置中解析入口点和加载器（默认情况下，使用当前目录）|
| entry  |打包入口：每个HTML页面一个入口点；SPA：一个入口点；MPA：多个入口点|
| compiler  | webpack 编译对象（只有一个），可在该对象上添加 事件钩子 |
| compilation  | webpack 在各个生命周期编译构建 bundle 的产物 |
| stats  | —— |

### 如何编写 plugin

> [官网文档位置](https://webpack.js.org/contribute/writing-a-plugin/)

::: tip 实现 html-webpack-plugin
- 确定需要操作的 webpack 生命周期，可读取打包生成的 chunk（emit/afterEmit）
- 确定需要传入的参数（template/filename ...）
- 取一个名字（HtmlInjectPlugin）
:::

开始编写
- webpack.config.js 中
```js{1,7-10}
const HtmlInjectPlugin = require('./HtmlInjectPlugin.js')

module.exports = {
  mode:　'development',
  entry: './src/index.js',
  plugins: [
    new HtmlInjectPlugin({
      template: './index.html',
      filename: 'index.html'
    })
  ]
}
```
- HtmlInjectPlugin.js

:::tip cheerio
cheerio 是 jquery 核心功能的一个快速灵活而又简洁的实现，主要是为了用在服务器端需要对 DOM 进行操作的地方
:::

```js
const cheerio = require('cheerio')
const fs = require('fs')
const path = require('path')

module.exports = class HtmlInjectPlugin {
  constructor(options) {
    // 保存传入的配置
    // 在 webpack.config.js 中 new 对象时传入的参数
    this.options = options
  }
  apply (compiler) {
    // 在 afterEmit 钩子中注册事件
    compiler.hooks.afterEmit.tap('HtmlInjectPlugin', (compilation) => {
      // 获取整个打包输入的目录
      let outputPath = compilation.options.output.path
      // 读取作为模板的 index.html
      let template = fs.readFileSync(path.resolve(process.cwd(), this.options.template), 'utf-8')
      // 将 html 模板 转为 DOM
      let $ = cheerio.load(template)

      // 遍历最终生成的 chunk 文件名
      Object.keys(compilation.assets).forEach((file) => {
        // 根据 chunk 名动态创建 script 标签，并插入到 body 下
        $('body').append($(`<script src="./${file}"></script>`))
      })
      // 将 DOM 转换成 文本并写入 webpack 输入目录中
      fs.writeFileSync(path.join(outputPath, this.options.filename), $.html())
    })
  }
}
```

整个流程可概括为：
1. 保存传入的配置
2. 在 afterEmit 钩子中注册事件
3. 获取整个打包输入的目录
4. 读取作为模板的 index.html，并转为 DOM
5. 遍历最终生成的 chunk 文件名，根据 chunk 名动态创建 script 标签，并插入到 body 下
6. 将修改后的 DOM 转换成 文本，并写入 webpack 输入目录中

至此一个简单的 webpack plugin 就完成了

## 实现一个 mini-webpack