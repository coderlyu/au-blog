(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{444:function(t,a,s){"use strict";s.r(a);var n=s(15),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"可视化笔记"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可视化笔记"}},[t._v("#")]),t._v(" 可视化笔记")]),t._v(" "),s("p",[t._v("canvas 和 webgl技术调研")]),t._v(" "),s("h2",{attrs:{id:"canvas-vs-webgl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#canvas-vs-webgl"}},[t._v("#")]),t._v(" canvas vs webgl")]),t._v(" "),s("ol",[s("li",[t._v("WebGL 是 OpenGL 的版本，它是一个 3D 引擎。它帮助用户在网络浏览器中执行 3D、2D 操作。")]),t._v(" "),s("li",[t._v("Canvas 是 HTML5 的一部分，允许其用户使用动态的、脚本渲染的 2D 形状。它可以被认为是具有更新位图图像的能力并且没有内置场景图的低级别。")]),t._v(" "),s("li",[t._v("这些用于具有抽象层的游戏（2D 和 3D），如 PIXI.js 和其他几个如 Three.JS 和 Unity。")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("比较内容")]),t._v(" "),s("th",[t._v("canvas")]),t._v(" "),s("th",[t._v("webgl ｜")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("开发者")]),t._v(" "),s("td",[t._v("由 Apple 推出，用于在内部和 MAC 操作系统中使用")]),t._v(" "),s("td",[t._v("Mozilla 基金会是 WebGL 组件的原始作者。但是，开发人员是 Kronos WebGL 工作组")])]),t._v(" "),s("tr",[s("td",[t._v("出现")]),t._v(" "),s("td",[t._v("2004年")]),t._v(" "),s("td",[t._v("2011年")])]),t._v(" "),s("tr",[s("td",[t._v("诞生")]),t._v(" "),s("td",[t._v("webgl的前身")]),t._v(" "),s("td",[t._v("WebGL 从 Canvas 3D 实验演变而来")])]),t._v(" "),s("tr",[s("td",[t._v("速度")]),t._v(" "),s("td",[t._v("谈到速度因素，Canvas 放慢了它的组件")]),t._v(" "),s("td",[t._v("WebGL 在速度方面优于 Canvas")])]),t._v(" "),s("tr",[s("td",[t._v("开发选择")]),t._v(" "),s("td",[t._v("通常首选用于 2D 渲染和相关作品")]),t._v(" "),s("td",[t._v("虽然它也可以在 2D 上工作，但更适合 3d")])])])]),t._v(" "),s("p",[t._v("区别：")]),t._v(" "),s("ol",[s("li",[t._v("canvas 元素是 HTML 元素，在其第 5代(HTML5) 中引入。这允许其用户使用 JavaScript 在屏幕上绘图；这种动态生成的图形和动画在客户端是可能的，而 WebGL 是一个非标准化的 API，它允许使用 JavaScript 实现 OpenGL 功能。可以使用浏览器渲染 3D")]),t._v(" "),s("li",[t._v("如果您的要求是 2D 游戏（高级），请确定画布。使用画布进行 2D 的惊人绘图功能。你的游戏性质决定了这种选择。如果你的需求是移动项目少的 2D 游戏，Canvas 是解决方案，如果有重复的新帧，那么对于这种渲染循环，你需要更喜欢 Webgl")])]),t._v(" "),s("p",[t._v("结论：")]),t._v(" "),s("ol",[s("li",[t._v("Canvas易于工作且学习曲线更容易，而另一些则难以执行并极大地影响了游戏行业。")]),t._v(" "),s("li",[t._v("当应用程序的要求是轻量级和面向 2D 时，Canvas 可以很好地工作。")]),t._v(" "),s("li",[t._v("WebGL 当您正在开发的工作将变得更加复杂，帧速率更高，最重要的是它的 3D。")]),t._v(" "),s("li",[t._v("每个都有其优点和缺点，当需要为您的工作选择合适的匹配时，用户的工作取决于这些。Canvas 和 WebGL 都有很好的库和用户基础")])]),t._v(" "),s("h2",{attrs:{id:"canvas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#canvas"}},[t._v("#")]),t._v(" canvas")]),t._v(" "),s("h3",{attrs:{id:"局部重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#局部重绘"}},[t._v("#")]),t._v(" 局部重绘")]),t._v(" "),s("ol",[s("li",[t._v("开始前先 "),s("code",[t._v("save()")]),t._v(" 保存上下文环境")]),t._v(" "),s("li",[t._v("然后用 "),s("code",[t._v("clearRect()")]),t._v(" 清空目标区域像素，然后用rect绘制一个相同的矩形路径（可以自行多次绘制，区域会叠加）")]),t._v(" "),s("li",[t._v("接着 "),s("code",[t._v("clip()")]),t._v(" 一下，之后所有的绘制操作都会自动被限制在rect的区域内。只要按正常方式去把跟重绘区相交的对象都绘制一遍就好了。")]),t._v(" "),s("li",[t._v("最后是调用restore()取消clip()的限制。")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// region 是重绘区")]),t._v("\ncontext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("save")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ncontext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("clearRect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("region"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("minX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" region"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("minY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" region"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" region"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("height"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ncontext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("region"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("minX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" region"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("minY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" region"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("width"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" region"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("height"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ncontext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("clip")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//在此绘制相关的显示对象...")]),t._v("\ncontext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("restore")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[t._v("接下来的关键是如何获取重绘区")]),t._v(" "),s("h4",{attrs:{id:"获取重绘区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#获取重绘区"}},[t._v("#")]),t._v(" 获取重绘区")]),t._v(" "),s("h2",{attrs:{id:"webgl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webgl"}},[t._v("#")]),t._v(" webgl")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://superxlcr.github.io/2019/02/20/%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%B4%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E6%B8%B2%E6%9F%93%EF%BC%8C%E5%85%B7%E4%BD%93%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用硬件加速渲染"),s("OutboundLink")],1)]),t._v(" "),s("h3",{attrs:{id:"性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),s("h4",{attrs:{id:"传统-gpu-位图生成算法性能问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传统-gpu-位图生成算法性能问题"}},[t._v("#")]),t._v(" 传统(GPU)位图生成算法性能问题")]),t._v(" "),s("ol",[s("li",[t._v("大量的循环处理，每个涉及的像素都要处理一遍（按照现在手机的分辨率，算算一帧有多少要处理的）")]),t._v(" "),s("li",[t._v("颜色融合其实就是浮点数插值算法，对每个次像素都要做，运算量巨大")])]),t._v(" "),s("p",[t._v("解决：")]),t._v(" "),s("ol",[s("li",[t._v("对于像素太多的问题，最好的办法就是"),s("strong",[t._v("脏区域渲染")]),t._v("。用人类话来说就是每次渲染的时候，最大化的在上一帧的基础上面进行，对本次这帧没有变化的像素来说直接忽略处理。")]),t._v(" "),s("li",[t._v("对于浮点数运算太多，可以通过"),s("strong",[t._v("多媒体指令")]),t._v("来加速。比如：ARM Neon Intel MMX SSE 等等。以ARM为例,ARM有 16个通用计算寄存器，16个Neon指令寄存器，16个VFP高精度浮点数运算加速器。其中Neon指令可以让程序在一个指令周期里面计算8个浮点数的运算，理想的情况下相当于比传统的浮点运算性能提升了8倍。当然这些指令主要就是用来处理多媒体的，所以又叫多媒体指令 也叫 SIMD指令（Single Instruction Multiple Data，单指令多数据流，Android的底层绘图库就有基于Neon的优化器，我也尝试过用SSE指令优化Windows平台API AlphaBlend函数）。")])]),t._v(" "),s("h4",{attrs:{id:"图形硬件和硬件的渲染方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图形硬件和硬件的渲染方式"}},[t._v("#")]),t._v(" 图形硬件和硬件的渲染方式")]),t._v(" "),s("h2",{attrs:{id:"图形渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图形渲染"}},[t._v("#")]),t._v(" 图形渲染")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://idom.me/articles/841.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("图形渲染"),s("OutboundLink")],1)]),t._v(" "),s("ol",[s("li",[s("p",[t._v("全屏刷新渲染"),s("br"),t._v("\n基于显示列表结构的渲染方式，最常的就是全屏刷新模式。这也是目前大多数游戏引擎普遍采用的方案，因为不管是原理还是实现都比较简单：首先设定一个时钟频率，例如通常是每秒执行60次。每次都单独刷新一次屏幕。刷新过程就是直接清空整个屏幕，然后从显示列表的根节点开始遍历，按顺序找到每个可呈现的显示对象节点，按照它的坐标和大小绘制到屏幕上。这样开发者只需要改变显示对象的位置属性，等待下一次时钟周期到来，改变就会自动刷新到屏幕上。由于通常情况下，并不是每秒60次显示列表每次都会发生改变，或者发生改变时仅有一小部分改变。因此清空整个屏幕重绘的方式虽然实现简单，但是不必要的开销比较大。")])]),t._v(" "),s("li",[s("p",[t._v("脏矩形渲染"),s("br"),t._v("\n脏矩形渲染是一种基于显示列表的局部刷新方法。依然是要有一个时钟频率，定时每秒执行60次。但区别是每次我们并不直接清空整个屏幕，而是首先计算屏幕上发生改变的区域，这里我们叫做重绘区，然后只清空指定的重绘区，并找出跟这个区域相交的所有显示对象重绘一遍。如果显示列表本次美并没有发生改变，那么将直接跳过本次绘制，什么也不做。")])])]),t._v(" "),s("p",[t._v("显而易见的是它能大幅提高屏幕整体渲染性能，特别是对于复杂UI界面的情况，全屏刷新算法会每秒60次不停地刷新所有UI对象，在有脏矩形渲染的情况下，哪改变绘制哪，极端情况直接跳过绘制，在复杂UI界面的情况非常容易达到满帧。另外脏矩形渲染能够节省设备电量以及降低发热量。我们曾经测试过同一个线上游戏，在更新到脏矩形渲染后，整体耗电量降到了原先的30%，发热量也从45度降低到了35度，结果还是非常显著的。")])])}),[],!1,null,null,null);a.default=e.exports}}]);